<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
/*основной шрифт*/
@font-face {
	font-family:'CODERROR';
	src:url('fonts/CODERROR16x16GNUUnifont.ttf') format('truetype');
}
@keyframes message_fade_out{
	0%{opacity:1;}
	50%{opacity:1;}
	100%{opacity:0;}
}
*{
	margin:0;
	padding:0;
	font-family:'CODERROR';
	letter-spacing:0;
	user-select:none;
	font-size:var(--symbol_size);
	line-height:1em;
	pointer-events:auto; /* Разрешить взаимодействие с HTML-элементами */
	image-rendering:var(--image_rendering);
}
html,body{
	width:100%;
	height:100%;
	margin:0;
	padding:0;
	overflow:hidden;
	background:#000;
}
body {
	display: flex;
	justify-content: center;
	align-items: center;
}
canvas{
	position:absolute;
	top:0;
	left:0;
	width:inherit;
	height:inherit;
	pointer-events:none;
	background: transparent !important;
	mix-blend-mode:normal;
}
#html-overlay{
	position:absolute;
	top:0;
	left:0;
	width: inherit;
	height: inherit;
	/*чтобы центрирование по вертикали работало*/
	display: flex;
	flex-direction: column;
}
pre{
	color:#fff;
	background:#000;
	width:min-content;
	height:min-content;
	display:inline-block;
}
.center-horizontal{
	width:max-content;
	margin-left:auto;
	margin-right:auto;
}
.center-vertical {
	flex: 1 1 auto; /* Занимает всё доступное пространство */
	display: flex;
	align-items: center; /* Центрирование по вертикали */
}
.center {
	flex: 1 1 auto; /* Занимает всё доступное пространство */
	display: flex;
	align-items: center; /* Центрирование по вертикали */
	justify-content: center; /* Центрирование по горизонтали */
}
.fill-parent{
	width:100%;
	height:100%;
}
.column{
	flex-direction:column;
}
button{
	background-color:transparent;
	color:#fff;
	border: none;
	cursor: pointer !important;
	outline: none;
}
.drop_zone {
	width:calc(var(--symbol_size) * 12);
	height:calc(var(--symbol_size) * 12);
	background:#00000066;
}
.scrollable{
	overflow-y:auto;
	overflow-x:auto;
	width:100%;
	height:100%;
	scrollbar-color:#fff #000;
}
.scrollable *{
	min-width:min-content;
	min-height:min-content;
}
.symbolic_hr{
	width:100%;
	min-width:0;
	min-height:0;
	height:max-content;
}
.symbolic_hr pre{
	contain:strict;
	width:100%;
	height:var(--symbol_size);
	overflow:hidden;
	white-space:nowrap;
}
#wrapper{
	position:relative;
}
select{
	background:#000;
	color:#fff;
	outline:none;
	border:none;
}
/* Для выпадающего списка */
select option{
	background:#000;
	color:#fff;
}
.wrap{
	flex-wrap:wrap;
}
textarea{
	background-color:#000;
	color:#fff;
	border:0px solid #fff;
	border-radius:0;
	white-space:normal;
	overflow-wrap:break-word;
	outline:none;
	::placeholder{
		color:#c8c8c8;
		opacity:1;
	}
	&:focus {
		border-color:#f0f;
		box-shadow:none;
	}
}
input[type="range"]{
	accent-color:#f0f;
}
input[type="checkbox"]{
	accent-color:#f0f;
}
#interface{
	visibility:collapse;
	position:absolute;
	top:0;
	left:0;
	width:inherit;
	height:inherit;
	padding:var(--symbol_size);
	pointer-events:none;
}
#chat_preview{
	position:absolute;
	bottom:0;
	left:0;
	display:flex;
	align-items:start;
	justify-content:left;
	flex-direction:column;
	width:50cqw;
	height:max-content;
	margin:var(--symbol_size);
	pointer-events:none;
}
#chat_preview .message{
	color:#fff;
	background-color:#0000007F;
	pointer-events:none;
	animation:message_fade_out 10s linear forwards;
	max-width:100%;
	word-wrap:break-word;
}
#hotbar{
	position:absolute;
	left:50cqw;/* Смещаем левый край к центру родителя */
	transform:translateX(-50%);/* Сдвигаем элемент назад на половину его ширины */
}
.hotbar_slot{
	background-image:url('images/interface/inventory/slot.png');
	background-size:contain;
	background-repeat:no-repeat;
	width:32px;
	height:32px;
	position:relative;
}
.row{
	display:flex;
}
.centered,#active_hotbar_slot_frame{
	position:absolute;
	top:50%;
	left:50%;
	/* коррекция положения элемента */
	transform:translate(-50%, -50%);
}
#active_hotbar_slot_frame{
	width:32px;
	height:32px;
	z-index:5;
}
#esc_menu{
	visibility:collapse;
	position:absolute;
	top:0;
	left:0;
	width:100cqw;
	height:100cqh;
	pointer-events:none;
}
#button_to_main_menu{
	position:absolute !important;
	bottom:var(--symbol_size);
	right:var(--symbol_size);
}
.inherit_colors{
	display:contents;
}
.inherit_colors *{
	color:inherit;
	background:inherit;
}
	</style>
	<link rel="icon" type="image/png">
</head>
<body>
	<div id="wrapper"></div>
	<script>
//Проверяем, является ли это окно основным
if(!window.location.search.includes('child=1')){
	//Параметры для нового окна
	const width=screen.width;
	const height=screen.height;
	const features=`width=${width},height=${height},left=${(screen.width-width)/2},top=${(screen.height-height)/2}`;
	//Пытаемся открыть новое окно
	const new_window=window.open(`${window.location.href}?child=1`,'_blank',features);
	if(new_window){
		// Закрываем текущее окно после успешного открытия
		window.close();
	}else{
		// Проверяем браузер пользователя
		const is_chrome=/Chrome/.test(navigator.userAgent)&&!/Edg|Edge/.test(navigator.userAgent);
		let chrome_alert='';
		if(!is_chrome){
			chrome_alert=`
				<div style="padding: 15px; color: #000; background: #ffeb3b; margin-bottom: 10px; border-radius: 4px;">
					Рекомендуется запускать в Google Chrome: 
					<a href="https://www.google.com/intl/ru_ru/chrome/" 
					target="_blank" 
					style="color: #ff00ff; text-decoration: underline;">
						https://www.google.com/intl/ru_ru/chrome/
					</a>
				</div>`;
		}
		// Формируем полное сообщение
		document.body.innerHTML=chrome_alert+`
			<div style="padding: 20px; color: white; background: #d32f2f; border-radius: 4px;">
				Разрешите всплывающие окна для этого сайта и обновите страницу!
			</div>`;
	}
}else{
	//Если это дочернее окно - загружаем приложение
	/*функция для загрузки скрипта*/
	function load_script(src){
		return new Promise((resolve,reject)=>{
			const script=document.createElement('script');
			script.src=src;
			script.onload=()=>resolve(src);
			script.onerror=()=>reject(new Error(`Ошибка загрузки скрипта: ${src}`));
			document.head.appendChild(script);
		});
	}
	//Предзагрузка шрифта
	const font=new FontFace('CODERROR','url(fonts/CODERROR16x16GNUUnifont.ttf)');
	font.load().then(function(loadedFont){
		document.fonts.add(loadedFont);
		/*загрузка скриптов*/
		Promise.all([
			load_script('scripts/pixi.min.js'),
			load_script('scripts/three.min.js'),
			load_script('initial_settings.js'),
			load_script('languages.js')
		])
		.then((loaded_scripts)=>{
			/*начальные скрипты загружены*/
			const app=new PIXI.Application({
				backgroundAlpha: 0, // Явно указываем полную прозрачность фона
				useContextAlpha: true,
				transparent:true,
				premultipliedAlpha: false, // Критически важно для корректной прозрачности
				preserveDrawingBuffer: true, // Для совместимости с Three.js
			});
			app.init().then(()=>{
				let room_data,player;
				let wrapper=document.getElementById('wrapper');
				/*версия CODERROR'а*/
				window.version='(1)0.32.0';
				/*добавление в разметку сцены three*/
				let three_container=document.createElement('div');
				three_container.id='three_container';
				let three_scene=new THREE.Scene();
				three_scene.background = null;
				let three_camera=new THREE.PerspectiveCamera(
					75, 
					window.innerWidth/window.innerHeight,
					0.1,
					1000
				);
				three_camera.position.z=1; // Камера внутри куба
				let three_renderer=new THREE.WebGLRenderer({alpha:true});
				three_renderer.setSize(window.innerWidth,window.innerHeight);
				three_renderer.shadowMap.enabled=false;//отключаем тени
				// Загрузчик для текстур
				let texture_loader=new THREE.TextureLoader();
				/*инициализирует коробку, на которую можно натянуть текстуру неба*/
				let skybox;

				// Исправленная функция создания материалов
				function create_skybox_materials(path_part, extension) {
					const sides = ['right', 'left', 'top', 'bottom', 'front', 'back'];
					return sides.map(side => {
						const texture = texture_loader.load(
							`${path_part}/${side}.${extension}`,
							undefined, // onLoad
							undefined, // onProgress
							(error) => {
								console.error('Error loading texture:', error);
							}
						);
						
						// Используем BasicMaterial вместо StandardMaterial
						return new THREE.MeshBasicMaterial({
							map:texture,
							side: THREE.BackSide,
						});
					});
				}

				// Исправленная функция инициализации неба
				function init_sky() {
					// Создаем временный куб с базовым материалом
					const geometry = new THREE.BoxGeometry(5, 5, 5);
					const material = new THREE.MeshBasicMaterial({ 
						color: 0x0000FF, // Синий вместо фиолетового
						side: THREE.BackSide
					});
					
					skybox = new THREE.Mesh(geometry, material);
					three_scene.add(skybox);
				}

				// Исправленная функция установки неба
				function set_sky(path_part, extension) {
					// Удаляем старый skybox с освобождением ресурсов
					if (skybox) {
						three_scene.remove(skybox);
						
						// Освобождаем геометрию
						if (skybox.geometry) {
							skybox.geometry.dispose();
						}
						
						// Освобождаем материалы
						if (Array.isArray(skybox.material)) {
							skybox.material.forEach(material => {
								if (material.map) material.map.dispose();
								material.dispose();
							});
						} else if (skybox.material) {
							if (skybox.material.map) skybox.material.map.dispose();
							skybox.material.dispose();
						}
					}

					// Создаем новые материалы с обработкой ошибок
					try {
						const geometry = new THREE.BoxGeometry(5, 5, 5);
						const materials = create_skybox_materials(path_part, extension);
						skybox = new THREE.Mesh(geometry, materials);
						three_scene.add(skybox);
					} catch (error) {
						console.error('Error creating skybox:', error);
						// Создаем fallback-небо
						init_sky();
					}
				}

				// Инициализация
				init_sky();
				set_sky('images/skies/glitch', 'png');
				/*добавление в основной canvas canvas-а three*/
				let background_texture,background_sprite
				// Инициализация текстуры и спрайта (выполняется один раз)
				function init_three_scene() {
					background_texture = PIXI.Texture.from(three_renderer.domElement);
					background_texture.baseTexture.autoUpdate = false; // Отключаем авто-обновление
					background_sprite = new PIXI.Sprite(background_texture);
					app.stage.addChildAt(background_sprite, 0);
				}
				init_three_scene();
				// Функция обновления
				function update_three_scene() {
					// Обновляем Three.js сцену
					skybox.rotation.y += 0.01;
					skybox.rotation.x += 0.005;
					three_renderer.render(three_scene, three_camera);

					// Принудительное обновление текстуры в PixiJS
					background_texture.baseTexture.update();
				}
				update_three_scene();
				/*добавление в разметку canvas-а pixijs*/
				wrapper.appendChild(app.view);
				//wrapper.appendChild(three_renderer.domElement);//удалить
				/*добавление в разметку html-overlay*/
				const overlay=document.createElement('div');
				overlay.id='html-overlay';
				wrapper.appendChild(overlay);
				/*добавление в разметку предпросмотра чата*/
				let chat_preview=document.createElement('div');
				chat_preview.id='chat_preview';
				wrapper.appendChild(chat_preview);
				/*добавление в разметку interface*/
				let interface=document.createElement('div');
				interface.id='interface';
				wrapper.appendChild(interface);
				/**/
				function print_to_chat(message){
					let message_element=create_element_from_HTML(`<div>${message}</div>`);
					message_element.classList.add('message');
					chat_preview.appendChild(message_element);
					message_element.addEventListener('animationend',()=>{
						message_element.remove();
					});
				}
				let room,preparation;
				function change_room(room_,preparation_=true,reset_overlay_=true){
					room=room_;
					preparation=preparation_;
					if(reset_overlay_){
						overlay.innerHTML=``;
					}
				}
				/*инициализирует матрицу символов*/
				let symbols_grid,columns,rows;
				function init_sumbols_grid(){
					symbols_grid=[];
					columns=0;
					rows=0;
					update_symbols_grid();
				}
				/*обновляет размеры матрицы символов*/
				function update_symbols_grid(){
					const newColumns = Math.ceil(app.renderer.width / symbol_size);
					const newRows = Math.ceil(app.renderer.height / symbol_size);
					
					// Ресайз существующей сетки
					if(newColumns !== columns || newRows !== rows) {
						// Удаляем лишние строки
						if(newRows < rows) {
							for(let y = newRows; y < rows; y++) {
								for(let x = 0; x < columns; x++) {
									symbols_grid[y][x].destroy({ children: true });
								}
							}
							symbols_grid.length = newRows;
						}
						
						// Добавляем новые строки
						if(newRows > rows) {
							for(let y = rows; y < newRows; y++) {
								symbols_grid[y] = [];
								for(let x = 0; x < Math.max(columns, newColumns); x++) {
									const symbol = new PIXI.Text('', text_style);
									symbol.resolution=20;
									symbol.position.set(x * symbol_size, y * symbol_size);
									app.stage.addChild(symbol);
									symbols_grid[y][x] = symbol;
								}
							}
						}
						
						// Обновляем колонки в каждой строке
						for(let y = 0; y < newRows; y++) {
							// Удаляем лишние колонки
							if(newColumns < columns) {
								for(let x = newColumns; x < columns; x++) {
									if(symbols_grid[y][x]) {
										symbols_grid[y][x].destroy({ children: true });
									}
								}
								symbols_grid[y].length = newColumns;
							}
							
							// Добавляем новые колонки
							if(newColumns > columns) {
								for(let x = columns; x < newColumns; x++) {
									const symbol = new PIXI.Text('', text_style);
									symbol.resolution=20;
									symbol.position.set(x * symbol_size, y * symbol_size);
									app.stage.addChild(symbol);
									symbols_grid[y][x] = symbol;
								}
							}
						}
						
						columns = newColumns;
						rows = newRows;
					}
				}
				/*настройки шрифтов*/
				const styleSheet=document.styleSheets[0];
				let symbol_size,font_size,text_style/*,pixel_in_pt=0.675 рудимент*/;
				function set_font_size(size_in_pixels){
					symbol_size=size_in_pixels;
					font_size=symbol_size/**pixel_in_pt рудимент*/;
					styleSheet.insertRule(":root{--symbol_size:"+font_size+"px !important;}",styleSheet.cssRules.length);
					text_style=new PIXI.TextStyle({
						fontFamily:'CODERROR',
						fontSize:symbol_size,
						trim:false,
						fill:0xFFFFFF,
					});
					init_sumbols_grid();
				}
				set_font_size(16);
				/**/
				const update_size=()=>{
					app.renderer.resize(wrapper.clientWidth,wrapper.clientHeight);
					update_symbols_grid();
					/*меняем способ масштабирования в зависимости от масштаба: если больше нормы - пиксельный, меньше - размытый*/
					styleSheet.insertRule(`:root{--image_rendering:${window.devicePixelRatio>=1?'pixelated':'auto'} !important;}`,styleSheet.cssRules.length);
					/*Обновляем three*/
					three_camera.aspect=window.innerWidth/window.innerHeight;
					three_camera.updateProjectionMatrix();
					three_renderer.setSize(window.innerWidth,window.innerHeight);
				};
				function visual_effect(number){
					/*заполняет случайными символами*/
					if(number==0){
						for(let y=0;y<symbols_grid.length;y++){
							for(let x=0;x<symbols_grid[y].length;x++){
								const symbol=symbols_grid[y][x];
								symbol.text=get_random_char();
								symbol.tint=get_random_color();
							}
						}
					}
					/*случайно поворачивает символы*/
					if(number==1){
						for(let y=0;y<symbols_grid.length;y++){
							for(let x=0;x<symbols_grid[y].length;x++){
								const symbol=symbols_grid[y][x];
								symbol.anchor.set(Math.random());
								symbol.rotation=Math.random();
							}
						}
					}
					/*откатывает предыдущий*/
					if(number==2){
						for(let y=0;y<symbols_grid.length;y++){
							for(let x=0;x<symbols_grid[y].length;x++){
								const symbol=symbols_grid[y][x];
								symbol.anchor.set(0);
								symbol.rotation=0;
							}
						}
					}
				}
				function init_printable_symbols(){
					window.printable_symbols='';
					let ranges = [
						[0x0020, 0x007F],   // Basic Latin (ASCII)
						[0x00A0, 0x00FF],   // Latin-1 Supplement
						[0x0400, 0x04FF],   // Cyrillic
						[0x0370, 0x03FF],   // Greek
						[0x3040, 0x309F],   // Hiragana
						[0x30A0, 0x30FF],   // Katakana
						[0x4E00, 0x9FFF],   // CJK Unified Ideographs (кандзи)
						[0x0600, 0x06FF],   // Arabic
						[0x0900, 0x097F],   // Devanagari
						[0x0E00, 0x0E7F],   // Thai
						[0xAC00, 0xD7AF],   // Hangul Syllables (корейский)
						[0x1F600, 0x1F64F]  // Emoji
					];
					for(let range of ranges){
						for(let codePoint=range[0];codePoint<=range[1];codePoint++){
							window.printable_symbols+=String.fromCodePoint(codePoint);
						}
					}
				}
				init_printable_symbols();
				function get_random_char(){
    				return window.printable_symbols[Math.floor(Math.random()*99)];
				}
				function get_random_color(){
					return Math.floor(Math.random()*0xFFFFFF);
				}
				//для иконки
				const dpr=window.devicePixelRatio||1;
				const favicon_size=Math.round(16*dpr);
				const canvas=document.createElement('canvas');
				canvas.width=favicon_size;
				canvas.height=favicon_size;
				const ctx=canvas.getContext('2d');
				ctx.font=`${symbol_size}px CODERROR`;
				ctx.textAlign='center';
				ctx.textBaseline='middle';
				const link=document.querySelector('link[rel="icon"]');
				function generate_favicon(){
					// Очищаем холст
					ctx.clearRect(0,0,favicon_size,favicon_size);
					// Настройки текста
					ctx.fillStyle=`#${get_random_color().toString(16).padStart(6,'0')}`;
					// Рисуем символ
					ctx.fillText(get_random_char(),favicon_size/2,favicon_size/2);
					// Обновляем иконку
					canvas.toBlob(blob=>{
						link.href=URL.createObjectURL(blob);
					},'image/png');
				}
				window.addEventListener('resize',update_size);
				/*обновление favicon*/
				const faviconInterval=setInterval(()=>{
					generate_favicon();
				},1000/5);
				/*функция генерации кода разметки pre с отсутствием фона у пробелов*/
				function get_transparent_space_text(text,color='#fff',background='#000'){
					const escapeHtml=(char)=>{
						const escapes={
							'<':'&lt;',
							'>':'&gt;',
							'&':'&amp;',
							'"':'&quot;',
							"'":'&#39;'
						};
						return escapes[char]||char;
					};
					const areStylesEqual=(a,b)=>{
						const aKeys=Object.keys(a);
						const bKeys=Object.keys(b);
						if(aKeys.length!==bKeys.length)return false;
						for(const key of aKeys){
							if(a[key]!==b[key])return false;
						}
						return true;
					};
					const tokenRegex=/(⦑[^⦒]*⦒)|(\n)|( )|(.)/g;
					const tokens=[];
					let match;
					while((match=tokenRegex.exec(text))!==null){
						if(match[1])tokens.push({type:'tag',value:match[1]});
						else if(match[2])tokens.push({type:'newline'});
						else if(match[3])tokens.push({type:'space'});
						else if(match[4])tokens.push({type:'char',value:match[4]});
					}
					const initialStyles={color,background};
					let currentStyles={...initialStyles};
					let output=[];
					let currentNonSpace={styles:null,content:[]};
					let currentSpace=[];
					const flushNonSpace=()=>{
						if(currentNonSpace.content.length===0)return;
						// Всегда добавляем наследование, если стили не изменены
						const baseStyles={color:'inherit',background:'inherit'};
						const mergedStyles=!areStylesEqual(currentNonSpace.styles,initialStyles) 
							?{...currentNonSpace.styles}
							:baseStyles;
						const styleStr=`style="${Object.entries(mergedStyles).map(([k,v])=>`${k}:${v}`).join(';')}"`;
						const content=currentNonSpace.content.map(escapeHtml).join('');
						output.push(`<pre ${styleStr}>${content}</pre>`);
						currentNonSpace.content=[];
						currentNonSpace.styles=null;
					};
					const flushSpace=()=>{
						if(currentSpace.length===0)return;
						// Только прозрачный фон и цвет если изменен
						const spaceStyles={
							background:'transparent',
							...(currentStyles.color!==initialStyles.color&&{color:currentStyles.color})
						};
						const styleStr=Object.keys(spaceStyles).length>0 
							?`style="${Object.entries(spaceStyles).map(([k,v])=>`${k}:${v}`).join(';')}"`
							:'';
						const content=currentSpace.map(escapeHtml).join('');
						output.push(`<pre ${styleStr}>${content}</pre>`);
						currentSpace=[];
					};
					for(const token of tokens){
						switch(token.type){
							case'tag':{
								const tagContent=token.value.slice(1,-1).trim();
								if(tagContent==='reset'){
									currentStyles={...initialStyles};
								}else{
									const[property,value]=tagContent.split(':').map(p=>p.trim());
									if(property&&value)currentStyles[property]=value;
								}
								flushNonSpace();
								flushSpace();
								break;
							}
							case'newline':
								flushNonSpace();
								flushSpace();
								output.push('<br>');
								break;
							case'space':
								flushNonSpace();
								currentSpace.push(' ');
								break;
							case'char':
								flushSpace();
								if(currentNonSpace.styles&&areStylesEqual(currentStyles,currentNonSpace.styles)){
									currentNonSpace.content.push(token.value);
								}else{
									flushNonSpace();
									currentNonSpace.styles={...currentStyles};
									currentNonSpace.content.push(token.value);
								}
								break;
						}
					}
					flushNonSpace();
					flushSpace();
					return`<div style="display:contents;color:${color};background:${background}">${output.join('')}</div>`;
				}
				/*принимает разметку, возвращает полноценный элемент*/
				function create_element_from_HTML(html){
					const template=document.createElement('template');
					template.innerHTML=html.trim();
					const fragment=template.content;
					// Проверяем, есть ли ровно один дочерний элемент
					if(fragment.childNodes.length===1&&fragment.firstChild.nodeType===Node.ELEMENT_NODE){
						return fragment.firstChild;
					}else{
						// Создаём контейнер с display: contents
						const container=document.createElement('div');
						container.style.display='contents';
						// Перемещаем все узлы из фрагмента в контейнер
						while(fragment.firstChild){
							container.appendChild(fragment.firstChild);
						}
						return container;
					}
				}
				/*возвращает один из ИСТИНЫХ цветов*/
				function get_random_true_str_color(){
					return get_random_element(['#000','#00f','#0f0','#0ff','#f00','#f0f','#ff0','#fff']);
				}
				/*увеличивает z-index на 1*/
				function increment_z_index(element){
					element.style.zIndex=parseInt(element.style.zIndex||0)+1+'';
				}
				/*оборачивает элемент в кнопку с символьной рамкой*/
				function wrap_in_frame(content,container_type='<button/>',removable=false) {
					let button = create_element_from_HTML(container_type);
					button.style.position='relative';
					button.style.overflow='hidden';
					let grid=document.createElement('div');
					grid.style.display='grid';
					grid.style.gridTemplateAreas=`"a . b" ". c ." "d . e"`;
					grid.style.gridTemplateColumns='repeat(3,min-content)';
					grid.style.gridTemplateRows='repeat(3,min-content)';
					grid.style.gap='0';
					grid.style.position='relative';
					grid.style.alignItems='center'; // Выравнивание по центру
					grid.style.justifyItems='center';
					grid.style.color='inherit';
					// Создание элементов с правильными областями
					let b;
					if(removable){
						b=create_element_from_HTML(`<pre><button style='color:inherit'>X</button></pre>`);/*костыль*/
						b.addEventListener('click',()=>{
							button.remove();
						});
					}
					else{
						b=create_element_from_HTML(`<pre>.</pre>`);
					}
					const elements={
						a:create_element_from_HTML(`<pre>+</pre>`),
						b:b,
						c:document.createElement('div'),
						d:create_element_from_HTML(`<pre>\`</pre>`),
						e:create_element_from_HTML(`<pre>'</pre>`)
					};
					// Настройка центрального элемента
					elements.c.appendChild(content);
					elements.c.style.gridArea='c';
					elements.c.style.whiteSpace='nowrap';
					elements.c.id='frame_content';
					// Привязка всех элементов к grid-areas
					Object.entries(elements).forEach(([area,el])=>{
						el.style.gridArea=area;
						el.style.color='inherit';
						grid.appendChild(el);
					});
					if(removable){
						b.style.color='#f00'
					}
					button.appendChild(grid);
					increment_z_index(grid);
					let horizontal=`<pre style="position:absolute;white-space:nowrap;color:inherit;">${'-'.repeat(666)}</pre>`
					let vertical=`<pre style="position:absolute;white-space:nowrap;color:inherit;">${'|<br>'.repeat(444)}</pre>`
					let top=create_element_from_HTML(horizontal);
					top.style.top=0;
					top.style.left=0;
					let bottom=create_element_from_HTML(horizontal);
					bottom.style.bottom=0;
					bottom.style.left=0;
					let left=create_element_from_HTML(vertical);
					left.style.top=0;
					left.style.left=0;
					let right=create_element_from_HTML(vertical);
					right.style.top=0;
					right.style.right=0;
					button.appendChild(top);
					button.appendChild(bottom);
					button.appendChild(left);
					button.appendChild(right);
					return button;
				}
				/*создает кнопку на основе текста*/
				function create_button_from_text(text,removable=false){
					return wrap_in_frame(create_element_from_HTML(get_transparent_space_text(text)),'<button/>',removable);
				}
				/*меняет цвет рамки кнопки*/
				function change_button_border_color(button,color){
					button.style.color=color;
				}
				/*меняет цвет текста кнопки*/
				function change_button_text_color(button,color){
					const targetElement=button.querySelector('#frame_content');
					const firstChild=targetElement.firstElementChild;
					if(firstChild){
						firstChild.style.color=color;
					}else{
						console.log('У элемента нет дочерних элементов.');
					}
				}
				/*меняет цвет рамки и текста кнопки*/
				function change_button_color(button,color){
					change_button_border_color(button,color);
					change_button_text_color(button,color);
				}
				/*проверяет перетаскивают ли файл над объектом*/
				const dragoverStates=new WeakMap();
				function check_dragover(element){
					if (!element.__dragoverHandlersAdded){
						const handlers={
							dragenter:(event)=>{
								event.preventDefault();
								if(!dragoverStates.get(element)){
									element.classList.add('dragover');
									dragoverStates.set(element,true);
								}
							},
							dragover:(event)=>{
								event.preventDefault();
								if(!dragoverStates.get(element)){
									element.classList.add('dragover');
									dragoverStates.set(element,true);
								}
							},
							dragleave:(event)=>{
								if(!event.relatedTarget||!element.contains(event.relatedTarget)){
									element.classList.remove('dragover');
									dragoverStates.set(element,false);
								}
							},
							drop:(event)=>{
								event.preventDefault();
								element.classList.remove('dragover');
								dragoverStates.set(element,false);
							}
						};
						element.addEventListener('dragenter',handlers.dragenter);
						element.addEventListener('dragover',handlers.dragover);
						element.addEventListener('dragleave',handlers.dragleave);
						element.addEventListener('drop',handlers.drop);
						element.__dragoverHandlersAdded=true;
						Object.assign(element,{__dragoverHandlers:handlers});
					}
					return dragoverStates.get(element)||false;
				}
				/*проверяет наведена ли мышь на элемент*/
				function check_hover(element){
					return(element.matches(':hover')||check_dragover(element));
				}
				/*возвращает новый br элемент*/
				function get_br(){
					return document.createElement('br');
				}
				/*превращает json файл в объект (требует async await)*/
				function json_to_dict(file){
					return new Promise((resolve,reject)=>{
						const reader=new FileReader();
						reader.onload=e=>{
							try{
								resolve(JSON.parse(e.target.result));
							}catch(error){
								reject(error);
							}
						};
						reader.onerror=error=>reject(error);
						reader.readAsText(file);
					});
				}
				/*превращает много json в объекты за раз*/
				async function jsons_to_dict_list(files){
					let data=[];
					for(let file of files){
						const parsed=await json_to_dict(file);
						data.push(parsed);
					}
					return data;
				}
				/*соединяет объекты в 1 более общий, перезаписывая старые значения новыми*/
				function smart_merge(config_list,max_depth=2){
					// Функция для глубокого слияния с ограничением глубины
					const merge=(target,source,depth=1)=>{
						// Если достигли предела глубины - возвращаем source
						if(depth>=max_depth)return{...source};
						// Создаем новый объект для результатов
						const result={...target};
						// Перебираем ключи исходного объекта
						for(const key of Object.keys(source)) {
							const sourceValue=source[key];
							const targetValue=target[key];
							// Если оба значения - объекты (не массивы) 
							if(typeof sourceValue==='object'&& 
								!Array.isArray(sourceValue)&&
								typeof targetValue==='object'&& 
								!Array.isArray(targetValue)){
								// Рекурсивное слияние с увеличением глубины
								result[key]=merge(targetValue,sourceValue,depth+1);
							}else{
								// Заменяем значение
								result[key]=sourceValue;
							}
						}
						return result;
					};
					let result=config_list[0];
					for(let i=1;i<config_list.length;i++){
						result=merge(result,config_list[i]);
					}
					return result;
				}
				/*создаёт кастомные обработчики событий*/
				const eventHandlers=new WeakMap();
				function add_event_listener(name,element,function_part){
					/*Удаляем старые обработчики перед добавлением новых*/
					remove_event_listener(name,element);
					const handlers={
						drop:null,
						click:null,
						change:null
					};
					if(name==='get_json'){
						const jsonInput=document.createElement('input');
						jsonInput.type='file';
						jsonInput.multiple=true;
						jsonInput.accept='.json';
						jsonInput.style.display='none';
						/*Обработчик для drag-and-drop*/
						const dropHandler=async(e)=>{
							e.preventDefault();
							try{
								const dicts=await jsons_to_dict_list(e.dataTransfer.files);
								const merged=smart_merge(dicts);
								function_part(merged);
							}catch(error){
								console.error('Ошибка:',error);
							}
						};
						/*Обработчик для клика (открытие проводника)*/
						const clickHandler=()=>{
							jsonInput.click();
						};
						/*Обработчик выбора файлов (общий для всех вызовов)*/
						const changeHandler=async(e)=>{
							try{
								const files=Array.from(e.target.files);
								const dicts=await jsons_to_dict_list(files);
								const merged=smart_merge(dicts);
								function_part(merged);
								jsonInput.value='';
							}catch(error){
								console.error('Ошибка:',error);
							}
						};
						/*Сохраняем ссылки на обработчики*/
						handlers.drop=dropHandler;
						handlers.click=clickHandler;
						handlers.change=changeHandler;
						/*Навешиваем обработчики*/
						element.addEventListener('drop',dropHandler);
						element.addEventListener('click',clickHandler);
						jsonInput.addEventListener('change',changeHandler);
						/*Сохраняем созданный input и обработчики*/
						eventHandlers.set(element,{
							name,
							handlers,
							elements:{jsonInput}
						});
					}
				}
				/*удаляет кастомные обработчики событий*/
				function remove_event_listener(name,element){
					const stored=eventHandlers.get(element);
					if(stored&&stored.name===name){
						/*Удаляем все обработчики событий*/
						element.removeEventListener('drop',stored.handlers.drop);
						element.removeEventListener('click',stored.handlers.click);
						stored.elements.jsonInput.removeEventListener('change',stored.handlers.change);
						/*Удаляем созданный input из DOM если был добавлен*/
						if(document.body.contains(stored.elements.jsonInput)){
							document.body.removeChild(stored.elements.jsonInput);
						}
						eventHandlers.delete(element);
					}
				}
				/*создает hr из -*/
				function get_symbolic_hr(){
					return create_element_from_HTML(`<div class='symbolic_hr'><pre>${'-'.repeat(666)}</pre></div>`);
				}
				/*принимает список названий языков и применяет их (чем больше индекс, тем выше приоритет)*/
				function apply_language(name_list){
					name_list=['default'].concat(name_list);
					let languages_list=[];
					for(name of name_list){
						languages_list.push(window.languages[name]);
					}
					window.language=smart_merge(languages_list,99);
				}
				/*принимает словарь текста и превращает его в кнопки*/
				function dict_to_buttons(dict){
					let buttons=structuredClone(dict);
					for(let key in buttons){
						buttons[key]=create_button_from_text(buttons[key]);
					}
					return buttons;
				}
				/*устанавливает ограничение максимального размера содержимого игры, "100%" отключает ограничение*/
				function set_max_content_size(max_width,max_height){
					wrapper.style.width=`min(100%,${max_width})`;
					wrapper.style.height=`min(100%,${max_height})`;
					update_size();
				}
				/*принимает select и список и устанавливает ему эти значения*/
				function set_select_options(selectElement,options) {
					selectElement.innerHTML='';
					options.forEach(optionText=>{
						let option=document.createElement('option');
						//option.value=optionText;// Задаем значение
						option.textContent=optionText;// Задаем текст отображения
						selectElement.appendChild(option);
					});
				}
				/*создает select с рамкой*/
				function create_select_with_frame(options,removable=false){
					let select=create_element_from_HTML('<select/>');
					set_select_options(select,options);
					select.style.margin='calc(-1 * var(--symbol_size))';
					select.style.padding='var(--symbol_size)';
					select.style.marginRight='0';
					select.style.cursor='pointer';
					select.style.background='#00000000';
					let frame=wrap_in_frame(select,`<button style='background:#000;'/>`,removable);
					frame.style.pointerEvents='none';
					return[frame,select];
				}
				/*создает прозрачный пробел для горизонтального отступа*/
				function get_space(){
					return create_element_from_HTML(`<pre style='background:#00000000'> </pre>`);
				}
				/* Функция для сохранения объекта как JSON файл*/
				function save_as_json(data,filename){
					// Преобразуем объект в JSON строку
					const jsonString=JSON.stringify(data);
					// Создаем Blob из JSON строки
					const blob=new Blob([jsonString],{type:"application/json"});
					// Создаем ссылку на объект Blob
					const url=URL.createObjectURL(blob);
					// Создаем временную ссылку для скачивания
					const a=document.createElement("a");
					a.href=url;
					a.download=filename;
					a.style.display='none';
					// Инициализируем клик по ссылке
					document.body.appendChild(a);
					a.click();
					// Удаляем ссылку и освобождаем URL
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
					/*уведомление*/
					alert(window.language.alerts.file_saved(filename));
				}
				/*удаляет из списка повторяющиеся значения, оставляя в нём только их последние вхождения*/
				function remove_duplicates(arr){
					const seen=new Set();
					const result=[];
					// Идем по массиву в обратном порядке
					for(let i=arr.length-1;i>=0;i--){
						const value=arr[i];
						if(!seen.has(value)){
							seen.add(value);
							result.push(value);
						}
					}
					// Перевернем результат, чтобы вернуть его в правильном порядке
					return result.reverse();
				}
				/*применяет к игре настройки из window.settings*/
				function apply_settings(){
					apply_language(window.settings.interface.language);
					apply_random_splash();
					//set_font_size(window.settings.interface.font_size);
					set_max_content_size(window.settings.interface.max_content_width,window.settings.interface.max_content_height);
					change_room(room);
				}
				/*создает textarea с рамкой*/
				function create_textarea_with_frame(placeholder='',removable=false){
					let textarea=create_element_from_HTML('<textarea/>');
					textarea.style.cursor='pointer';
					textarea.style.background='#00000000';
					textarea.placeholder=placeholder;
					let frame=wrap_in_frame(textarea,`<button style='background:#000;'/>`,removable);
					frame.addEventListener('click',(e)=>{
						textarea.focus();
					})
					return[frame,textarea];
				}
				/*музыка*/
				let current_music=null;
				let current_music_path='';
				let music_volume=0.5;
				let audio_initialized=false;
				/*для того чтобы музыка начинала проигрываться после нажатия на любое место страницы*/
				function init_audio(){
					if(!audio_initialized){
						audio_initialized=true;
						document.removeEventListener('click',init_audio);
						if(current_music){
							current_music.play().catch(handle_play_error);
						}
					}
				}
				document.addEventListener('click',init_audio);
				/*принимает путь до музыки и включает её*/
				function set_music(path){
					if(current_music_path===path)return;
					if(current_music){
						current_music.pause();
						current_music=null;
					}
					current_music=new Audio(path);
					current_music.volume=music_volume;
					current_music.loop=true;
					current_music_path=path;
					if(audio_initialized){
						current_music.play().catch(handle_play_error);
					}
					print_to_chat(window.language.notifications.current_music(path));
				}
				/*выводит сообщение об ошибке в случае её возникновения*/
				function handle_play_error(error){
					console.error('Playback error:',error);
				}
				/*устанавливает громкость*/
				function set_volume(volume){
					music_volume=Math.max(0,Math.min(1,volume));
					if(current_music)current_music.volume=music_volume;
				}
				/*меняет текст кастомной кнопки*/
				function change_button_text(button,text){
					button.querySelector('#frame_content').innerHTML=get_transparent_space_text(text);
				}
				/*ожидает пользовательский ввод и возвращает promise*/
				window.ignored_keys=['F11','F12'];
				function wait_user_input(){
					return new Promise((resolve)=>{
						const handler=(e)=>{
							if(!window.ignored_keys.includes(e.code)){
								e.preventDefault();
								document.removeEventListener('keydown',handler);
								document.removeEventListener('mousedown',handler);
								document.removeEventListener('wheel',handler);
								if(e.type==='keydown'){
									if(window.settings.control.bind_to_layout){
										resolve(e.key);
									}else{
										resolve(e.code);
									}
								}else if(e.type==='mousedown'){
									resolve(`mouse${e.button}`);
								}else if(e.type==='wheel') {
									resolve(e.deltaY<0?'WheelUp':'WheelDown');
								}
							}
						};
					document.addEventListener('keydown',handler);
					document.addEventListener('mousedown',handler);
					document.addEventListener('wheel',handler);
					});
				}
				/*принимает список и возвращает случайный элемент*/
				function get_random_element(list){
					return list[Math.floor(Math.random()*list.length)];
				}
				/*устанавливает случайный сплеш*/
				function apply_random_splash(){
					window.splash=get_random_element(window.language.splashes);
				}
				/*очищает сцену pixijs*/
				function clear_pixijs(stage=app.stage){
					stage.removeChildren();
				}
				/*отслеживает нажатия и отжатия клавиш*/
				window.pressed=new Set();
				window.activated_actions=new Set();
				function update_activated_actions(){
					window.activated_actions.clear();
					Object.entries(window.settings.control).forEach(([control_id,control])=>{
						if(control_id!='bind_to_layout'){
							for(let key of control){
								if(window.pressed.has(key)){
									window.activated_actions.add(control_id);
									break;
								}
							}
						}
					});
				}
				function setup_input_tracker(){
					const getKey=(e)=>{
						if(e.type.startsWith('key')){
							return window.settings.control.bind_to_layout?e.key:e.code;
						}else if(e.type.startsWith('mouse')&&e.type!=='wheel'){
							return`mouse${e.button}`;
						}else if(e.type==='wheel'){
							return e.deltaY<0?'WheelUp':'WheelDown';
						}
					};
					const handleEvent=(e)=>{
						if(!e.repeat){/*Отключаем автоповтор*/
							if(!window.ignored_keys.includes(e.code)){
								const key=getKey(e);
								if(e.type==='keydown'||e.type==='mousedown'||e.type==='wheel'){
									window.pressed.add(key);
								}else{
									window.pressed.delete(key);
								}
								update_activated_actions();
							}
						}
					};
					document.addEventListener('keydown',handleEvent);
					document.addEventListener('keyup',handleEvent);
					document.addEventListener('mousedown',handleEvent);
					document.addEventListener('mouseup',handleEvent);
					document.addEventListener('wheel', handleEvent);
					return{
						stop_tracking:()=>{
							document.removeEventListener('keydown',handleEvent);
							document.removeEventListener('keyup',handleEvent);
							document.removeEventListener('mousedown',handleEvent);
							document.removeEventListener('mouseup',handleEvent);
							document.removeEventListener('wheel', handleEvent);
						}
					};
				}
				/*отрисовывает текст в symbols_grid*/
				function print_text_to_symbols_grid(text,x,y,color=0xFFFFFF){
					x=Math.floor(x);
					y=Math.floor(y);
					let current_x=x,current_y=y;
					for(let symbol of text){
						if(current_x>=0&&current_x<symbols_grid[0].length&&current_y>=0&&current_y<symbols_grid.length){
							let pixi_symbol=symbols_grid[current_y][current_x];
							pixi_symbol.text=symbol;
							pixi_symbol.tint=color;
						}
						if(symbol=='\n'){
							current_x=x;
							current_y++;
						}
						else{
							current_x++;
						}
					}
				}
				/*превращает текст в коллайдер в зависимости от размера шрифта*/
				function text_to_collider(text,void_symbols=['',' ']){
					let lines=text.split("\n"),collider=[];
					for(let line of lines){
						let temp_row=[];
						for(let char of line){
							temp_row.push(...Array(logical_symbol_size).fill(!void_symbols.includes(char)));
						}
						for(let y=0;y<logical_symbol_size;y++){
							collider.push([...temp_row]);
						}
					}
					return collider;
				}
				/*очищает symbols_grid*/
				function clear_symbols_grid(){
					for(let y=0;y<symbols_grid.length;y++){
						for(let x=0;x<symbols_grid[y].length;x++){
							symbols_grid[y][x].text='';
							symbols_grid[y][x].backgroundColor=0x00000000;
						}
					}
				}
				/*выполняет скрипт в текущей области видимости*/
				function eval_script(path){
					fetch(path)
						.then(res=>res.text())
						.then(script=>{
							eval(script);
						});
				}
				/*переводит логические координаты в координаты на экране*/
				function logical_to_screen(num){
					return num/logical_symbol_size*symbol_size;
				}
				/*настройки камеры*/
				function focus_camera_on_player(){
					room_data.camera=[logical_to_screen(player.coordinates[0])-(Math.floor(columns/2)*symbol_size),logical_to_screen(player.coordinates[1])-(Math.floor(rows/2)*symbol_size)];
				}
				/*расчет коллайдеров*/
				function update_player_collider(){
					player.collider=[[player.coordinates[0],player.coordinates[1]],[player.coordinates[0]+logical_symbol_size,player.coordinates[1]+logical_symbol_size]];
				}
				/*расчет коллизии*/
				let nothing_below,nothing_left,nothing_right,nothing_higher;
				function update_collision(ground_collider=room_data.ground.collider){
					update_player_collider();
					nothing_below=true;
					nothing_left=true;
					nothing_right=true;
					nothing_higher=true;
					for(let y=player.collider[0][1];y<player.collider[1][1];y++){
						for(let x=player.collider[0][0];x<player.collider[1][0];x++){
							let coordinates=[x,y+1];
							if(coordinates.every(num=>num>=0)){
								try{
									if(ground_collider[coordinates[1]][coordinates[0]]){
										nothing_below=false;
									}
								}catch{}
							}
							coordinates=[x,y-1];
							if(coordinates.every(num=>num>=0)){
								try{
									if(ground_collider[coordinates[1]][coordinates[0]]){
										nothing_higher=false;
									}
								}catch{}
							}
							coordinates=[x+1,y];
							if(coordinates.every(num=>num>=0)){
								try{
									if(ground_collider[coordinates[1]][coordinates[0]]){
										nothing_right=false;
									}
								}catch{}
							}
							coordinates=[x-1,y];
							if(coordinates.every(num=>num>=0)){
								try{
									if(ground_collider[coordinates[1]][coordinates[0]]){
										nothing_left=false;
									}
								}catch{}
							}
						}
					}
				}
				/*устанавливает рамку на активный слот хотбара*/
				function update_active_hotbar_slot_frame(){
					let active_hotbar_slot_frame=document.getElementById('active_hotbar_slot_frame');
					if(!active_hotbar_slot_frame){
						active_hotbar_slot_frame=create_element_from_HTML(`<img id="active_hotbar_slot_frame" src="images/interface/inventory/active_slot_frame.png"/>`);
					}
					document.querySelector(`.hotbar_slot[data-index="${player.interface.hotbar.active_slot_index}"]`).appendChild(active_hotbar_slot_frame);
				}
				/*генерирует хотбар*/
				function generate_hotbar(){
					let hotbar=create_element_from_HTML(`<div id="hotbar" class="row"></div>`);
					for(let i=0;i<player.interface.hotbar.slot_count;i++){
						let slot=document.createElement('div');
						slot.dataset.index=i;
						slot.classList.add('hotbar_slot');
						slot.addEventListener('click',function(e){
							player.interface.hotbar.active_slot_index=this.dataset.index;
							update_active_hotbar_slot_frame();
						});
						hotbar.appendChild(slot);
					}
					return hotbar;
				}
				function generate_esc_menu(){
					let esc_menu=create_element_from_HTML(`<div id="esc_menu"></div>`);
					let button_to_main_menu=create_button_from_text(window.language.interface.buttons.to_main_menu);
					button_to_main_menu.addEventListener('click',()=>{
						change_room('main_menu');
					});
					button_to_main_menu.id='button_to_main_menu';
					esc_menu.appendChild(button_to_main_menu);
					return esc_menu;
				}
				/*генерирует интерфейс*/
				function update_interface(){
					interface.innerHTML='';
					interface.appendChild(generate_hotbar());
					update_active_hotbar_slot_frame();
					interface.appendChild(generate_esc_menu());
				}
				/*включает/отключает интерфейс*/
				function set_interface_visibility(is_visible){
					if(is_visible){
						interface.style.visibility='visible';
					}else{
						interface.style.visibility='collapse';
					}
				}
				/*активирует прошлый слот хотбара*/
				function activate_previous_hotbar_slot(){
					player.interface.hotbar.active_slot_index--;
					if(player.interface.hotbar.active_slot_index<0){
						player.interface.hotbar.active_slot_index=player.interface.hotbar.slot_count-1;
					}
					update_active_hotbar_slot_frame();
				}
				/*активирует следующий слот хотбара*/
				function activate_next_hotbar_slot(){
					player.interface.hotbar.active_slot_index++;
					if(player.interface.hotbar.active_slot_index>=player.interface.hotbar.slot_count){
						player.interface.hotbar.active_slot_index=0;
					}
					update_active_hotbar_slot_frame();
				}
				/*финальная настройка*/
				document.addEventListener('contextmenu',(e)=>{
					e.preventDefault();/*отключаем контекстные меню глобально. я сам ими пользовался для вызова консоли, но они могут помешать игре, если что-то забинжено на правую кнопку мыши*/
				});
				room='main_menu'
				apply_settings();
				let input_tracker=setup_input_tracker();
				let logical_symbol_size=16;
				/*загрузка циклов физики и отрисовки*/
				eval_script('core/logic.js');
				eval_script('core/rendering.js');
			}).catch(console.error);
		})
		.catch((error)=>{
			console.error(error);
		});
	}).catch(function(error){
		console.error('Font loading failed:',error);
	});
}
	</script>
</body>
</html>
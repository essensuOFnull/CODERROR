<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<script src="languages.js" id="languages_script"></script>
	<style>
@font-face{
	font-family:'CODERROR';
	src:url('fonts/CODERROR.ttf')format('truetype');
	font-weight:normal;
	font-style:normal;
	font-display:block;
}
*{
	margin:0;
	padding:0;
	font-family:'CODERROR',monospace;
	letter-spacing:0;
	user-select:none;
	font-size:var(--symbol_size);
	pointer-events:auto; /* Разрешить взаимодействие с HTML-элементами */
}
html,body{
	width:100%;
	height:100%;
	margin:0;
	padding:0;
	overflow:hidden;
}
canvas{
	display:block;
}
#html-overlay{
	position:absolute;
	top:0;
	left:0;
	width:100vw;
	height:100vh;
	/*чтобы центрирование по вертикали работало*/
	display: flex;
	flex-direction: column;
	min-height: 100vh;
}
pre{
	color:#fff;
	background:#000;
	width:min-content;
	height:min-content;
	display:inline-block;
}
.center-horizontal{
	width:max-content;
	margin-left:auto;
	margin-right:auto;
}
.center-vertical {
	flex: 1 1 auto; /* Занимает всё доступное пространство */
	display: flex;
	align-items: center; /* Центрирование по вертикали */
}
.center {
	flex: 1 1 auto; /* Занимает всё доступное пространство */
	display: flex;
	align-items: center; /* Центрирование по вертикали */
	justify-content: center; /* Центрирование по горизонтали */
}
.column{
	flex-direction:column;
}
button{
	background-color:transparent;
	color:#fff;
	border: none;
	cursor: pointer !important;
	outline: none;
}
.drop_zone {
	width:calc(var(--symbol_size) * 12);
	height:calc(var(--symbol_size) * 12);
	/*border:1px solid #fff;
	border-radius:var(--symbol_size);*/
	background:#00000066;
}
.scrollable{
	overflow-y:scroll;
	overflow-x:scroll;
	width:100%;
	height:100%;
	scrollbar-color:#fff #000;
}
	</style>
	<link rel="icon" type="image/png">
</head>
<body>
	<script>
//Проверяем, является ли это окно основным
if(!window.location.search.includes('child=1')){
	//Параметры для нового окна
	const width=800;
	const height=600;
	const features=`width=${width},height=${height},left=${(screen.width-width)/2},top=${(screen.height-height)/2}`;
	//Пытаемся открыть новое окно
	const new_window=window.open(`${window.location.href}?child=1`,'_blank',features);
	if(new_window){
		// Закрываем текущее окно после успешного открытия
		window.close();
	}else{
		// Проверяем браузер пользователя
		const is_chrome=/Chrome/.test(navigator.userAgent)&&!/Edg|Edge/.test(navigator.userAgent);
		let chrome_alert='';
		if(!is_chrome){
			chrome_alert=`
				<div style="padding: 15px; color: #000; background: #ffeb3b; margin-bottom: 10px; border-radius: 4px;">
					Рекомендуется запускать в Google Chrome: 
					<a href="https://www.google.com/intl/ru_ru/chrome/" 
					target="_blank" 
					style="color: #ff00ff; text-decoration: underline;">
						https://www.google.com/intl/ru_ru/chrome/
					</a>
				</div>`;
		}
		// Формируем полное сообщение
		document.body.innerHTML=chrome_alert+`
			<div style="padding: 20px; color: white; background: #d32f2f; border-radius: 4px;">
				Разрешите всплывающие окна для этого сайта и обновите страницу!
			</div>`;
	}
}else{
	//Если это дочернее окно - загружаем приложение
	const pixijs=document.createElement('script');
	pixijs.src='scripts/pixi.min.js';
	//Предзагрузка шрифта
	const font=new FontFace('CODERROR','url(fonts/CODERROR.ttf)');
	font.load().then(function(loadedFont){
		document.fonts.add(loadedFont);
		//Запускаем загрузку Pixi только после загрузки шрифта
		document.head.appendChild(pixijs);
	}).catch(function(error){
		console.error('Font loading failed:',error);
	});
	pixijs.onload=function(){
		/*дожидаемся загрузки языков на всякий случай*/
		const languages_script=document.createElement('script');
		languages_script.src='languages.js';
		document.head.appendChild(languages_script);
		languages_script.onload=function(){
			const app=new PIXI.Application({
				backgroundColor:0x000000,
			});
			app.init().then(()=>{
				/*версия CODERROR'а*/
				window.version='(1)0.14.1';
				/*добавление в разметку canvas-а pixijs*/
				document.body.appendChild(app.view);
				/*добавление в разметку html-overlay*/
				const overlay=document.createElement('div');
				overlay.id='html-overlay';
				document.body.appendChild(overlay);
				/**/
				let room,preparation;
				function change_room(room_,preparation_=true,reset_overlay_=true){
					room=room_;
					preparation=preparation_;
					if(reset_overlay_){
						overlay.innerHTML=``;
					}
				}
				let symbols_grid=[];//двумерный массив для символов
				let columns=0;
				let rows=0;
				function update_symbols_grid(){
					columns=Math.ceil(app.renderer.width/symbol_size);
					rows=Math.ceil(app.renderer.height/symbol_size);
					// Удаляем старые символы
					symbols_grid.forEach(row=>{
						row.forEach(symbol=>symbol.destroy());
					});
					symbols_grid=[];// Сбрасываем массив
					// Создаем новую сетку
					for(let y=0;y<rows;y++){
						symbols_grid[y]=[];
						for(let x=0;x<columns;x++){
							const symbol=new PIXI.Text('',text_style);
							symbol.resolution=20;
							symbol.position.set(x*symbol_size,y*symbol_size);
							app.stage.addChild(symbol);
							symbols_grid[y][x]=symbol;
						}
					}
				}
				/*настройки шрифтов*/
				const styleSheet=document.styleSheets[0];
				let symbol_size,font_size,text_style,pixel_in_pt=0.675;
				function set_font_size(size_in_pixels){
					symbol_size=size_in_pixels;
					font_size=symbol_size*pixel_in_pt;
					styleSheet.insertRule(":root{--symbol_size:"+font_size+"pt !important;}",styleSheet.cssRules.length);
					text_style=new PIXI.TextStyle({
						fontFamily:'CODERROR',
						fontSize:symbol_size,
						fill:0xFFFFFF,
					});
					update_symbols_grid();
				}
				set_font_size(10);
				/**/
				const update_size=()=>{
					app.renderer.resize(window.innerWidth,window.innerHeight);
					update_symbols_grid();
				};
				function visual_effect(number){
					/*заполняет случайными символами*/
					if(number==0){
						for(let y=0;y<symbols_grid.length;y++){
							for(let x=0;x<symbols_grid[y].length;x++){
								const symbol=symbols_grid[y][x];
								symbol.text=get_random_char();
								symbol.tint=get_random_color();
							}
						}
					}
					/*случайно поворачивает символы*/
					if(number==1){
						for(let y=0;y<symbols_grid.length;y++){
							for(let x=0;x<symbols_grid[y].length;x++){
								const symbol=symbols_grid[y][x];
								symbol.anchor.set(Math.random());
								symbol.rotation=Math.random();
							}
						}
					}
					/*откатывает предыдущий*/
					if(number==2){
						for(let y=0;y<symbols_grid.length;y++){
							for(let x=0;x<symbols_grid[y].length;x++){
								const symbol=symbols_grid[y][x];
								symbol.anchor.set(0);
								symbol.rotation=0;
							}
						}
					}
				}
				function get_random_char(){
					return String.fromCharCode(Math.floor(Math.random()*(126-33+1))+33);
				}
				function get_random_color(){
					return Math.floor(Math.random()*0xFFFFFF);
				}
				//для иконки
				const dpr=window.devicePixelRatio||1;
				const favicon_size=Math.round(16*dpr);
				const canvas=document.createElement('canvas');
				canvas.width=favicon_size;
				canvas.height=favicon_size;
				const ctx=canvas.getContext('2d');
				ctx.font=`${symbol_size}px CODERROR`;
				ctx.textAlign='center';
				ctx.textBaseline='middle';
				const link=document.querySelector('link[rel="icon"]');
				function generate_favicon(){
					// Очищаем холст
					ctx.clearRect(0,0,favicon_size,favicon_size);
					// Настройки текста
					ctx.fillStyle=`#${get_random_color().toString(16).padStart(6,'0')}`;
					// Рисуем символ
					ctx.fillText(get_random_char(),favicon_size/2,favicon_size/2);
					// Обновляем иконку
					canvas.toBlob(blob=>{
						link.href=URL.createObjectURL(blob);
					},'image/png');
				}
				window.addEventListener('resize',update_size);
				/*обновление favicon*/
				const faviconInterval=setInterval(()=>{
					generate_favicon();
				},1000/5);
				/*функция генерации кода разметки pre с отсутствием фона у пробелов*/
				function get_transparent_space_text(text,color='#fff',background='#000'){
					const escapeHtml=(char)=>{
						const escapes={
							'<':'&lt;',
							'>':'&gt;',
							'&':'&amp;',
							'"':'&quot;',
							"'":'&#39;'
						};
						return escapes[char]||char;
					};
					const areStylesEqual=(a,b)=>{
						const aKeys=Object.keys(a);
						const bKeys=Object.keys(b);
						if(aKeys.length!==bKeys.length)return false;
						for(const key of aKeys){
							if(a[key]!==b[key])return false;
						}
						return true;
					};
					const tokenRegex=/(⦑[^⦒]*⦒)|(\n)|( )|(.)/g;
					const tokens=[];
					let match;
					while((match=tokenRegex.exec(text))!==null){
						if(match[1])tokens.push({type:'tag',value:match[1]});
						else if(match[2])tokens.push({type:'newline'});
						else if(match[3])tokens.push({type:'space'});
						else if(match[4])tokens.push({type:'char',value:match[4]});
					}
					const initialStyles={color,background};
					let currentStyles={...initialStyles};
					let output=[];
					let currentNonSpace={styles:null,content:[]};
					let currentSpace=[];
					const flushNonSpace=()=>{
						if(currentNonSpace.content.length===0)return;
						// Всегда добавляем наследование, если стили не изменены
						const baseStyles={color:'inherit',background:'inherit'};
						const mergedStyles=!areStylesEqual(currentNonSpace.styles,initialStyles) 
							?{...currentNonSpace.styles}
							:baseStyles;
						const styleStr=`style="${Object.entries(mergedStyles).map(([k,v])=>`${k}:${v}`).join(';')}"`;
						const content=currentNonSpace.content.map(escapeHtml).join('');
						output.push(`<pre ${styleStr}>${content}</pre>`);
						currentNonSpace.content=[];
						currentNonSpace.styles=null;
					};
					const flushSpace=()=>{
						if(currentSpace.length===0)return;
						// Только прозрачный фон и цвет если изменен
						const spaceStyles={
							background:'transparent',
							...(currentStyles.color!==initialStyles.color&&{color:currentStyles.color})
						};
						const styleStr=Object.keys(spaceStyles).length>0 
							?`style="${Object.entries(spaceStyles).map(([k,v])=>`${k}:${v}`).join(';')}"`
							:'';
						const content=currentSpace.map(escapeHtml).join('');
						output.push(`<pre ${styleStr}>${content}</pre>`);
						currentSpace=[];
					};
					for(const token of tokens){
						switch(token.type){
							case'tag':{
								const tagContent=token.value.slice(1,-1).trim();
								if(tagContent==='reset'){
									currentStyles={...initialStyles};
								}else{
									const[property,value]=tagContent.split(':').map(p=>p.trim());
									if(property&&value)currentStyles[property]=value;
								}
								flushNonSpace();
								flushSpace();
								break;
							}
							case'newline':
								flushNonSpace();
								flushSpace();
								output.push('<br>');
								break;
							case'space':
								flushNonSpace();
								currentSpace.push(' ');
								break;
							case'char':
								flushSpace();
								if(currentNonSpace.styles&&areStylesEqual(currentStyles,currentNonSpace.styles)){
									currentNonSpace.content.push(token.value);
								}else{
									flushNonSpace();
									currentNonSpace.styles={...currentStyles};
									currentNonSpace.content.push(token.value);
								}
								break;
						}
					}
					flushNonSpace();
					flushSpace();
					return`<div style="display:contents;color:${color};background:${background}">${output.join('')}</div>`;
				}
				/*принимает разметку, возвращает полноценный элемент*/
				function create_element_from_HTML(html){
					const template=document.createElement('template');
					template.innerHTML=html.trim();
					const fragment=template.content;
					// Проверяем, есть ли ровно один дочерний элемент
					if(fragment.childNodes.length===1&&fragment.firstChild.nodeType===Node.ELEMENT_NODE){
						return fragment.firstChild;
					}else{
						// Создаём контейнер с display: contents
						const container=document.createElement('div');
						container.style.display='contents';
						// Перемещаем все узлы из фрагмента в контейнер
						while(fragment.firstChild){
							container.appendChild(fragment.firstChild);
						}
						return container;
					}
				}
				/*возвращает один из ИСТИНЫХ цветов*/
				function get_random_true_str_color(){
					const colors=['#000','#00f','#0f0','#0ff','#f00','#f0f','#ff0','#fff'];
					return colors[Math.floor(Math.random()*colors.length)];
				}
				/*увеличивает z-index на 1*/
				function increment_z_index(element){
					element.style.zIndex=parseInt(element.style.zIndex||0)+1+'';
				}
				/*оборачивает элемент в кнопку с символьной рамкой*/
				function wrap_in_button(content) {
					let button = document.createElement('button');
					button.style.position='relative';
					button.style.overflow='hidden';
					let grid=document.createElement('div');
					grid.style.display='grid';
					grid.style.gridTemplateAreas=`"a . b" ". c ." "d . e"`;
					grid.style.gridTemplateColumns='repeat(3,min-content)';
					grid.style.gridTemplateRows='repeat(3,min-content)';
					grid.style.gap='0';
					grid.style.position='relative';
					grid.style.alignItems='center'; // Выравнивание по центру
					grid.style.justifyItems='center';
					grid.style.color='inherit';
					// Создание элементов с правильными областями
					const elements={
						a:create_element_from_HTML(`<pre>+</pre>`),
						b:create_element_from_HTML(`<pre>.</pre>`),
						c:document.createElement('div'),
						d:create_element_from_HTML(`<pre>\`</pre>`),
						e:create_element_from_HTML(`<pre>'</pre>`)
					};
					// Настройка центрального элемента
					elements.c.appendChild(content);
					elements.c.style.gridArea='c';
					elements.c.style.whiteSpace='nowrap';
					// Привязка всех элементов к grid-areas
					Object.entries(elements).forEach(([area,el])=>{
						el.style.gridArea=area;
						el.style.color='inherit';
						grid.appendChild(el);
					});
					button.appendChild(grid);
					increment_z_index(grid);
					let horizontal=`<pre style="position:absolute;white-space:nowrap;color:inherit;">${'-'.repeat(666)}</pre>`
					let vertical=`<pre style="position:absolute;white-space:nowrap;color:inherit;">${'|<br>'.repeat(444)}</pre>`
					let top=create_element_from_HTML(horizontal);
					top.style.top=0;
					top.style.left=0;
					let bottom=create_element_from_HTML(horizontal);
					bottom.style.bottom=0;
					bottom.style.left=0;
					let left=create_element_from_HTML(vertical);
					left.style.top=0;
					left.style.left=0;
					let right=create_element_from_HTML(vertical);
					right.style.top=0;
					right.style.right=0;
					button.appendChild(top);
					button.appendChild(bottom);
					button.appendChild(left);
					button.appendChild(right);
					return button;
				}
				/*создает кнопку на основе текста*/
				function create_button_from_text(text){
					return wrap_in_button(create_element_from_HTML(get_transparent_space_text(text)));
				}
				/*меняет цвет рамки кнопки*/
				function change_button_border_color(button,color){
					button.style.color=color;
				}
				/*меняет цвет текста кнопки*/
				function change_button_text_color(button,color){
					const elements=button.querySelectorAll('[style*="grid-area: c;"]');
					if(elements.length>0){
						const targetElement=elements[0];
						const firstChild=targetElement.firstElementChild;
						if(firstChild){
							firstChild.style.color=color;
						}else{
							console.log('У элемента нет дочерних элементов.');
						}
					}else{
						console.log('Элемент с grid-area: c; не найден.');
					}
				}
				/*меняет цвет рамки и текста кнопки*/
				function change_button_color(button,color){
					change_button_border_color(button,color);
					change_button_text_color(button,color);
				}
				/*проверяет перетаскивают ли файл над объектом*/
				const dragoverStates=new WeakMap();
				function check_dragover(element){
					if (!element.__dragoverHandlersAdded){
						const handlers={
							dragenter:(event)=>{
								event.preventDefault();
								if(!dragoverStates.get(element)){
									element.classList.add('dragover');
									dragoverStates.set(element,true);
								}
							},
							dragover:(event)=>{
								event.preventDefault();
								if(!dragoverStates.get(element)){
									element.classList.add('dragover');
									dragoverStates.set(element,true);
								}
							},
							dragleave:(event)=>{
								if(!event.relatedTarget||!element.contains(event.relatedTarget)){
									element.classList.remove('dragover');
									dragoverStates.set(element,false);
								}
							},
							drop:(event)=>{
								event.preventDefault();
								element.classList.remove('dragover');
								dragoverStates.set(element,false);
							}
						};
						element.addEventListener('dragenter',handlers.dragenter);
						element.addEventListener('dragover',handlers.dragover);
						element.addEventListener('dragleave',handlers.dragleave);
						element.addEventListener('drop',handlers.drop);
						element.__dragoverHandlersAdded=true;
						Object.assign(element,{__dragoverHandlers:handlers});
					}
					return dragoverStates.get(element)||false;
				}
				/*проверяет наведена ли мышь на элемент*/
				function check_hover(element){
					return(element.matches(':hover')||check_dragover(element));
				}
				/*возвращает новый br элемент*/
				function get_br(){
					return document.createElement('br');
				}
				/*превращает json файл в объект (требует async await)*/
				function json_to_dict(file){
					return new Promise((resolve,reject)=>{
						const reader=new FileReader();
						reader.onload=e=>{
							try{
								resolve(JSON.parse(e.target.result));
							}catch(error){
								reject(error);
							}
						};
						reader.onerror=error=>reject(error);
						reader.readAsText(file);
					});
				}
				/*превращает много json в объекты за раз*/
				async function jsons_to_dict_list(files){
					let data=[];
					for(let file of files){
						const parsed=await json_to_dict(file);
						data.push(parsed);
					}
					return data;
				}
				/*соединяет объекты в 1 более общий, перезаписывая старые значения новыми*/
				function smart_merge(config_list,max_depth=2){
					// Функция для глубокого слияния с ограничением глубины
					const merge=(target,source,depth=1)=>{
						// Если достигли предела глубины - возвращаем source
						if(depth>=max_depth)return{...source};
						// Создаем новый объект для результатов
						const result={...target};
						// Перебираем ключи исходного объекта
						for(const key of Object.keys(source)) {
							const sourceValue=source[key];
							const targetValue=target[key];
							// Если оба значения - объекты (не массивы) 
							if(typeof sourceValue==='object'&& 
								!Array.isArray(sourceValue)&&
								typeof targetValue==='object'&& 
								!Array.isArray(targetValue)){
								// Рекурсивное слияние с увеличением глубины
								result[key]=merge(targetValue,sourceValue,depth+1);
							}else{
								// Заменяем значение
								result[key]=sourceValue;
							}
						}
						return result;
					};
					let result=config_list[0];
					for(let i=1;i<config_list.length;i++){
						result=merge(result,config_list[i]);
					}
					return result;
				}
				/*создаёт кастомные обработчики событий*/
				const eventHandlers=new WeakMap();
				function add_event_listener(name,element,function_part){
					/*Удаляем старые обработчики перед добавлением новых*/
					remove_event_listener(name,element);
					const handlers={
						drop:null,
						click:null,
						change:null
					};
					if(name==='get_json'){
						const jsonInput=document.createElement('input');
						jsonInput.type='file';
						jsonInput.multiple=true;
						jsonInput.accept='.json';
						jsonInput.style.display='none';
						/*Обработчик для drag-and-drop*/
						const dropHandler=async(e)=>{
							e.preventDefault();
							try{
								const dicts=await jsons_to_dict_list(e.dataTransfer.files);
								const merged=smart_merge(dicts);
								function_part(merged);
							}catch(error){
								console.error('Ошибка:',error);
							}
						};
						/*Обработчик для клика (открытие проводника)*/
						const clickHandler=()=>{
							jsonInput.click();
						};
						/*Обработчик выбора файлов (общий для всех вызовов)*/
						const changeHandler=async(e)=>{
							try{
								const files=Array.from(e.target.files);
								const dicts=await jsons_to_dict_list(files);
								const merged=smart_merge(dicts);
								function_part(merged);
								jsonInput.value='';
							}catch(error){
								console.error('Ошибка:',error);
							}
						};
						/*Сохраняем ссылки на обработчики*/
						handlers.drop=dropHandler;
						handlers.click=clickHandler;
						handlers.change=changeHandler;
						/*Навешиваем обработчики*/
						element.addEventListener('drop',dropHandler);
						element.addEventListener('click',clickHandler);
						jsonInput.addEventListener('change',changeHandler);
						/*Сохраняем созданный input и обработчики*/
						eventHandlers.set(element,{
							name,
							handlers,
							elements:{jsonInput}
						});
					}
				}
				/*удаляет кастомные обработчики событий*/
				function remove_event_listener(name,element){
					const stored=eventHandlers.get(element);
					if(stored&&stored.name===name){
						/*Удаляем все обработчики событий*/
						element.removeEventListener('drop',stored.handlers.drop);
						element.removeEventListener('click',stored.handlers.click);
						stored.elements.jsonInput.removeEventListener('change',stored.handlers.change);
						/*Удаляем созданный input из DOM если был добавлен*/
						if(document.body.contains(stored.elements.jsonInput)){
							document.body.removeChild(stored.elements.jsonInput);
						}
						eventHandlers.delete(element);
					}
				}
				/*создает hr из -*/
				function get_symbolic_hr(){
					return create_element_from_HTML(`<div style='overflow:hidden;width:100%;height:max-content'><pre style='white-space:nowrap'>${'-'.repeat(666)}</pre></div>`);
				}
				/*принимает список названий языков и применяет их (чем больше индекс, тем выше приоритет)*/
				function apply_language(name_list){
					let languages_list=[];
					for(name of name_list){
						languages_list.push(window.languages[name]);
					}
					window.language=smart_merge(languages_list,99);
				}
				/*принимает словарь текста и превращает его в кнопки*/
				function dict_to_buttons(dict){
					let buttons=structuredClone(dict);
					for(let key in buttons){
						buttons[key]=create_button_from_text(buttons[key]);
					}
					return buttons;
				}
				/*финальная настройка*/
				let room_data;
				window.settings={
					interface:{
						language:['default']
					}
				}
				apply_language(window.settings.interface.language);
				change_room('main_menu');
				/*главный цикл*/
				app.ticker.add(()=>{
					document.title=`CODERROR ${window.version} FPS: ${app.ticker.FPS.toFixed(2)}`;
					if(room=='main_menu'){
						if(preparation){
							room_data={
								info:create_element_from_HTML(`<div>${get_transparent_space_text(`CODERROR ${window.version} by essensuOFnull`,'#c8c8c8')}</div>`),
								logo:create_element_from_HTML(`<div class="center-horizontal">${get_transparent_space_text(String.raw`
/T\ /T\ PT\ P] PT\ PT\ /T\ PT\
L U L q L q H  L q L q L q L q
L   L q L q H] L_/ L_/ L q L_/
L n L q L q H  U n U n L q U n
\_/ \_/ L_/ L] U U U U \_/ U U`.trim())}</div>`),
								buttons_div:create_element_from_HTML(`<div class="center column"/>`),
								buttons:dict_to_buttons(window.language.rooms[room].buttons),
								bug_counter:0
							};
							overlay.appendChild(room_data.info);
							overlay.appendChild(room_data.logo);
							change_button_color(room_data.buttons.exit,'#f00');
							Object.entries(room_data.buttons).forEach(([name,el])=>{
								room_data.buttons_div.appendChild(el);
								room_data.buttons_div.appendChild(get_br());
							});
							overlay.appendChild(room_data.buttons_div);
							room_data.buttons.exit.addEventListener('click',()=>{
								alert("⚠️ ERROR 400: Bad Request");
								self.close();
							});
							room_data.buttons.authors.addEventListener('click',()=>{
								change_room('authors');
							});
							room_data.buttons.settings.addEventListener('click',()=>{
								change_room('settings');
							});
							preparation=false;
						}
						visual_effect(0);
						room_data.logo.firstChild.style.color=get_random_true_str_color();
						Object.entries(room_data.buttons).forEach(([name,el])=>{
							if(name=='exit'){
								el.style.marginLeft=`calc(var(--symbol_size) * ${-0.5+Math.floor(Math.random()*2)})`;
								if(check_hover(el)){
									visual_effect(1);
									room_data.bug_counter=100;
								}
								else{
									if(room_data.bug_counter<=0){
										visual_effect(2);
									}
									else{
										room_data.bug_counter--;
									}
								}
							}
							else{
								if(check_hover(el)){
									change_button_color(el,get_random_true_str_color());
								}
								else{
									change_button_color(el,'#fff');
								}
							}
						});
					}
					if(room=='authors'){
						if(preparation){
							room_data={
								scrollable:create_element_from_HTML(`<div class="scrollable"/>`),
								div1:create_element_from_HTML(`<div class="center column"/>`),
								contribution:structuredClone(Object.entries(window.language.contribution)),
								div2:create_element_from_HTML(`<div class="center column"/>`),
								buttons:{
									back:create_button_from_text(`назад`)
								},
							};
							overlay.appendChild(room_data.scrollable);
							room_data.scrollable.appendChild(room_data.div1);
							room_data.contribution.forEach(([name,contribution],i)=>{
								room_data.contribution[i]=create_element_from_HTML(`<div>${get_transparent_space_text(`${name}⦑reset⦒ - ${contribution}`)}</div>`);
								room_data.div1.appendChild(get_br());
								room_data.div1.appendChild(room_data.contribution[i]);
							});
							overlay.appendChild(room_data.div2);
							room_data.div2.appendChild(room_data.buttons.back);
							room_data.buttons.back.addEventListener('click',()=>{
								change_room('main_menu');
							});
							preparation=false;
						}
						visual_effect(0);
						if(check_hover(room_data.buttons.back)){
							change_button_color(room_data.buttons.back,get_random_true_str_color());
						}
						else{
							change_button_color(room_data.buttons.back,'#fff');
						}
							
					}
					if(room=='settings'){
						if(preparation){
							room_data={
								scrollable:create_element_from_HTML(`<div class='scrollable'/>`),
								div1:create_element_from_HTML(`<div class="center column"/>`),
								drop_zone:wrap_in_button(create_element_from_HTML(`<div class='drop_zone center'><div style='text-align:center;'>${get_transparent_space_text(window.language.rooms[room].drop_zone)}</div></div>`)),
								div2:create_element_from_HTML(`<div class="center column"/>`),
								buttons:dict_to_buttons(window.language.rooms[room].buttons),
							};
							overlay.appendChild(room_data.scrollable);
							room_data.scrollable.appendChild(room_data.div1);
							room_data.div1.appendChild(room_data.drop_zone);
							room_data.div1.appendChild(get_br());
							Object.entries(window.language.rooms[room].sections).forEach(([name,text])=>{
								room_data.div1.appendChild(get_symbolic_hr());
								room_data.div1.appendChild(create_element_from_HTML(`<div>${get_transparent_space_text(text)}</div>`));
								room_data.div1.appendChild(get_symbolic_hr());
								room_data.div1.appendChild(get_br());
							});
							overlay.appendChild(room_data.div2);
							room_data.div2.appendChild(room_data.buttons.back);
							add_event_listener('get_json',room_data.drop_zone,(data)=>{console.log(data);});
							room_data.buttons.back.addEventListener('click',()=>{
								change_room('main_menu');
							});
							preparation=false;
						}
						visual_effect(0);
						if(check_hover(room_data.drop_zone)){
							change_button_border_color(room_data.drop_zone,'#f0f');
						}
						else{
							change_button_border_color(room_data.drop_zone,'#fff');
						}
						Object.entries(room_data.buttons).forEach(([name,el])=>{
							if(check_hover(el)){
								change_button_color(el,get_random_true_str_color());
							}
							else{
								change_button_color(el,'#fff');
							}
						});
					}
					window.PERMITTED={ 
						set_font_size
					};
				});
				app.ticker.maxFPS=60;
			}).catch(console.error);
		}
	}
}
	</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>CODERROR</title>
    <style>
        @font-face{
            font-family:'CODERROR';
            src:url('fonts/CODERROR.ttf')format('truetype');
            font-weight:normal;
            font-style:normal;
            font-display:block;
        }
        *{
            margin:0;
            padding:0;
            font-family:'CODERROR',monospace;
            letter-spacing:0;
            user-select:none;
        }
        html,body{
            width:100%;
            height:100%;
            margin:0;
            padding:0;
            overflow:hidden;
        }
        canvas{
            display:block;
        }
        #html-overlay{
            position:absolute;
            top:0;
            left:0;
            width:100vw;
            height:100vh;
            pointer-events:auto; /* Разрешить взаимодействие с HTML-элементами */
        }
        pre{
            color:#fff;
            background:#000;
            width:min-content;
            height:min-content;
            display:inline-block;
        }
        .center-horizontal{
            width:max-content;
            margin-left:auto;
            margin-right:auto;
        }
    </style>
    <link rel="icon" type="image/png">
</head>
<body>
    <script>
        //Проверяем, является ли это окно основным
        if(!window.location.search.includes('child=1')){
            //Параметры для нового окна
            const width=800;
            const height=600;
            const features=`width=${width},height=${height},left=${(screen.width-width)/2},top=${(screen.height-height)/2}`;
            //Пытаемся открыть новое окно
            const new_window=window.open(`${window.location.href}?child=1`,'_blank',features);
            if(new_window){
                // Закрываем текущее окно после успешного открытия
                window.close();
            }else{
                // Проверяем браузер пользователя
                const is_chrome=/Chrome/.test(navigator.userAgent)&&!/Edg|Edge/.test(navigator.userAgent);
                let chrome_alert='';
                if(!is_chrome){
                    chrome_alert=`
                        <div style="padding: 15px; color: #000; background: #ffeb3b; margin-bottom: 10px; border-radius: 4px;">
                            Рекомендуется запускать в Google Chrome: 
                            <a href="https://www.google.com/intl/ru_ru/chrome/" 
                            target="_blank" 
                            style="color: #ff00ff; text-decoration: underline;">
                                https://www.google.com/intl/ru_ru/chrome/
                            </a>
                        </div>`;
                }
                // Формируем полное сообщение
                document.body.innerHTML=chrome_alert+`
                    <div style="padding: 20px; color: white; background: #d32f2f; border-radius: 4px;">
                        Разрешите всплывающие окна для этого сайта и обновите страницу!
                    </div>`;
            }
        }else{
            //Если это дочернее окно - загружаем приложение
            const script=document.createElement('script');
            script.src='scripts/pixi.min.js';
            //Предзагрузка шрифта
            const font=new FontFace('CODERROR','url(fonts/CODERROR.ttf)');
            font.load().then(function(loadedFont){
                document.fonts.add(loadedFont);
                //Запускаем загрузку Pixi только после загрузки шрифта
                document.head.appendChild(script);
            }).catch(function(error){
                console.error('Font loading failed:',error);
            });
            script.onload=function() {
                //Весь код приложения
                const app=new PIXI.Application({
                    backgroundColor:0x000000,
                });
                app.init().then(()=>{
                    /*добавление в разметку canvas-а pixijs*/
                    document.body.appendChild(app.view);
                    /*добавление в разметку html-overlay*/
                    const overlay=document.createElement('div');
                    overlay.id='html-overlay';
                    document.body.appendChild(overlay);
                    /**/
                    let room,preparation;
                    function change_room(room_,preparation_=true){
                        room=room_;
                        preparation=preparation_;
                    }
                    let symbols_grid=[];//двумерный массив для символов
                    let columns=0;
                    let rows=0;
                    function update_symbols_grid(){
                        columns=Math.ceil(app.renderer.width/symbol_size);
                        rows=Math.ceil(app.renderer.height/symbol_size);
                        // Удаляем старые символы
                        symbols_grid.forEach(row=>{
                            row.forEach(symbol=>symbol.destroy());
                        });
                        symbols_grid=[];// Сбрасываем массив
                        // Создаем новую сетку
                        for(let y=0;y<rows;y++){
                            symbols_grid[y]=[];
                            for(let x=0;x<columns;x++){
                                const symbol=new PIXI.Text('',text_style);
                                symbol.resolution=20;
                                symbol.position.set(x*symbol_size,y*symbol_size);
                                app.stage.addChild(symbol);
                                symbols_grid[y][x]=symbol;
                            }
                        }
                    }
                    /*настройки шрифтов*/
                    const styleSheet=document.styleSheets[0];
                    let symbol_size,font_size,text_style,pixel_in_pt=0.675;
                    function set_font_size(size_in_pixels){
                        symbol_size=size_in_pixels;
                        font_size=symbol_size*pixel_in_pt;
                        styleSheet.insertRule("*{font-size:"+font_size+"pt !important;}",styleSheet.cssRules.length);
                        text_style=new PIXI.TextStyle({
                            fontFamily:'CODERROR',
                            fontSize:symbol_size,
                            fill:0xFFFFFF,
                        });
                        update_symbols_grid();
                    }
                    set_font_size(10);
                    /**/
                    const update_size=()=>{
                        app.renderer.resize(window.innerWidth,window.innerHeight);
                        update_symbols_grid();
                    };
                    function visual_effect(number){
                        if(number==0){
                            for(let y=0;y<symbols_grid.length;y++){
                                for(let x=0;x<symbols_grid[y].length;x++){
                                    const symbol=symbols_grid[y][x];
                                    symbol.text=get_random_char();
                                    symbol.tint=get_random_color();
                                }
                            }
                        }
                    }
                    function get_random_char(){
                        return String.fromCharCode(Math.floor(Math.random()*(126-33+1))+33);
                    }
                    function get_random_color(){
                        return Math.floor(Math.random()*0xFFFFFF);
                    }
                    //для иконки
                    const dpr=window.devicePixelRatio||1;
                    const favicon_size=Math.round(16*dpr);
                    const canvas=document.createElement('canvas');
                    canvas.width=favicon_size;
                    canvas.height=favicon_size;
                    const ctx=canvas.getContext('2d');
                    ctx.font=`${symbol_size}px CODERROR`;
                    ctx.textAlign='center';
                    ctx.textBaseline='middle';
                    const link=document.querySelector('link[rel="icon"]');
                    
                    function generate_favicon(){
                        // Очищаем холст
                        ctx.clearRect(0,0,favicon_size,favicon_size);
                        // Настройки текста
                        ctx.fillStyle=`#${get_random_color().toString(16).padStart(6,'0')}`;
                        // Рисуем символ
                        ctx.fillText(get_random_char(),favicon_size/2,favicon_size/2);
                        // Обновляем иконку
                        canvas.toBlob(blob=>{
                            link.href=URL.createObjectURL(blob);
                        },'image/png');
                    }
                    window.addEventListener('resize',update_size);
                    /*обновление favicon*/
                    const faviconInterval=setInterval(()=>{
                        generate_favicon();
                    },1000/5);
                    /*функция генерации кода разметки pre с отсутствием фона у пробелов*/
                    function get_transparent_space_text(text, color = '#fff', background = '#000') {
                        const escapeHtml = (char) => {
                            const escapes = {
                                '<': '&lt;',
                                '>': '&gt;',
                                '&': '&amp;',
                                '"': '&quot;',
                                "'": '&#39;'
                            };
                            return escapes[char] || char;
                        };

                        const areStylesEqual = (a, b) => {
                            const aKeys = Object.keys(a);
                            const bKeys = Object.keys(b);
                            if (aKeys.length !== bKeys.length) return false;
                            for (const key of aKeys) {
                                if (a[key] !== b[key]) return false;
                            }
                            return true;
                        };

                        const tokenRegex = /(⦑[^⦒]*⦒)|(\n)|( )|(.)/g;
                        const tokens = [];
                        let match;
                        while ((match = tokenRegex.exec(text)) !== null) {
                            if (match[1]) tokens.push({ type: 'tag', value: match[1] });
                            else if (match[2]) tokens.push({ type: 'newline' });
                            else if (match[3]) tokens.push({ type: 'space' });
                            else if (match[4]) tokens.push({ type: 'char', value: match[4] });
                        }

                        const initialStyles = { color, background };
                        let currentStyles = { ...initialStyles };
                        let output = [];
                        let currentNonSpace = { styles: null, content: [] };
                        let currentSpace = [];

                        const flushNonSpace = () => {
                            if (currentNonSpace.content.length === 0) return;
                            
                            // Всегда добавляем наследование, если стили не изменены
                            const baseStyles = { color: 'inherit', background: 'inherit' };
                            const mergedStyles = !areStylesEqual(currentNonSpace.styles, initialStyles) 
                                ? { ...currentNonSpace.styles }
                                : baseStyles;

                            const styleStr = `style="${Object.entries(mergedStyles).map(([k, v]) => `${k}:${v}`).join(';')}"`;
                            const content = currentNonSpace.content.map(escapeHtml).join('');
                            output.push(`<pre ${styleStr}>${content}</pre>`);
                            currentNonSpace.content = [];
                            currentNonSpace.styles = null;
                        };

                        const flushSpace = () => {
                            if (currentSpace.length === 0) return;
                            
                            // Только прозрачный фон и цвет если изменен
                            const spaceStyles = {
                                background: 'transparent',
                                ...(currentStyles.color !== initialStyles.color && { color: currentStyles.color })
                            };
                            
                            const styleStr = Object.keys(spaceStyles).length > 0 
                                ? `style="${Object.entries(spaceStyles).map(([k, v]) => `${k}:${v}`).join(';')}"`
                                : '';
                            
                            const content = currentSpace.map(escapeHtml).join('');
                            output.push(`<pre ${styleStr}>${content}</pre>`);
                            currentSpace = [];
                        };

                        for (const token of tokens) {
                            switch (token.type) {
                                case 'tag': {
                                    const tagContent = token.value.slice(1, -1).trim();
                                    
                                    if (tagContent === 'reset') {
                                        currentStyles = { ...initialStyles };
                                    } else {
                                        const [property, value] = tagContent.split(':').map(p => p.trim());
                                        if (property && value) currentStyles[property] = value;
                                    }
                                    
                                    flushNonSpace();
                                    flushSpace();
                                    break;
                                }
                                case 'newline':
                                    flushNonSpace();
                                    flushSpace();
                                    output.push('<br>');
                                    break;
                                case 'space':
                                    flushNonSpace();
                                    currentSpace.push(' ');
                                    break;
                                case 'char':
                                    flushSpace();
                                    if (currentNonSpace.styles && areStylesEqual(currentStyles, currentNonSpace.styles)) {
                                        currentNonSpace.content.push(token.value);
                                    } else {
                                        flushNonSpace();
                                        currentNonSpace.styles = { ...currentStyles };
                                        currentNonSpace.content.push(token.value);
                                    }
                                    break;
                            }
                        }

                        flushNonSpace();
                        flushSpace();

                        return `<div style="display:contents;color:${color};background:${background}">${output.join('')}</div>`;
                    }
                    /*принимает разметку, возвращает полноценный элемент*/
                    function create_element_from_HTML(html){
                        const template=document.createElement('template');
                        template.innerHTML=html.trim();
                        const fragment=template.content;
                        // Проверяем, есть ли ровно один дочерний элемент
                        if(fragment.childNodes.length===1&&fragment.firstChild.nodeType===Node.ELEMENT_NODE){
                            return fragment.firstChild;
                        }else{
                            // Создаём контейнер с display: contents
                            const container=document.createElement('div');
                            container.style.display='contents';
                            // Перемещаем все узлы из фрагмента в контейнер
                            while(fragment.firstChild){
                                container.appendChild(fragment.firstChild);
                            }
                            return container;
                        }
                    }
                    /*возвращает один из ИСТИНЫХ цветов*/
                    function get_random_true_str_color(){
                        const colors=['#000','#00f','#0f0','#0ff','#f00','#f0f','#ff0','#fff'];
                        return colors[Math.floor(Math.random()*colors.length)];
                    }
                    /*финальная настройка*/
                    let room_data;
                    let logo_text=String.raw`
/T\ /T\ PT\ P] PT\ PT\ /T\ PT\
L U L q L q H  L q L q L q L q
L   L q L q H] L_/ L_/ L q L_/
L n L q L q H  U n U n L q U n
\_/ \_/ L_/ L] U U U U \_/ U U`.trim();
                    change_room(0);
                    /*главный цикл*/
                    app.ticker.add(()=>{
                        document.title=`CODERROR FPS: ${app.ticker.FPS.toFixed(2)}`;
                        if(room==0){
                            if(preparation){
                                room_data={
                                    info:create_element_from_HTML(get_transparent_space_text(`by essensuOFnull`,'#c8c8c8')),
                                    logo:create_element_from_HTML(`<div class="center-horizontal">${get_transparent_space_text(logo_text)}</div>`)
                                };
                                overlay.appendChild(room_data.info);
                                overlay.appendChild(room_data.logo);
                                preparation=false;
                            }
                            visual_effect(0);
                            room_data.logo.firstChild.style.color=get_random_true_str_color();
                        }
                        window.PERMITTED={ 
                            set_font_size
                        };
                    });
                    app.ticker.maxFPS=60;
                }).catch(console.error);
            };
            document.head.appendChild(script);
        }
    </script>
</body>
</html>